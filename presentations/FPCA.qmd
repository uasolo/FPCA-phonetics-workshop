---
title: "Simultaneous analysis of contours and durations"
author: "Michele Gubian"
date: "01 07 2024"
date-format: long
bibliography: references.bib
nocite: |
  @*
format:
  revealjs:
    toc: true
    toc-depth: 1
    toc-title: Outline
    df-print: kable
    slide-number: true
    chalkboard: 
      theme: "whiteboard"
    theme: [style.scss]
editor: visual
fig-cap-location: top
tab-cap-location: top
---

# Motivation

## f0 contours and (syllable) boundaries

::: {layout-ncol="2"}
::: fragment
![](plots/ex1D.6_curves_Cat.png)
:::

::: fragment
![](plots/ex1D.6_curves_land.png)
:::
:::

## f0 contours and (syllable) boundaries

::: {layout-ncol="2"}
![](plots/ex1D.6_curve3.png)


![](plots/ex1D.6_curve73.png)

:::

## Predicted curves and boundary positions

![](plots/ex1D.6_pred_curves_lands.png){height="500"}


## Predicted curves and durations

::: {layout-ncol="2"}
![Time-aligned curves](plots/ex1D.6_pred_curves.png)

![Interval durations](plots/ex1D.6_pred_dur.png)

:::





# Operations on functions

## From time samples to functions

::: {layout-ncol="2"}
![Sampled curve](plots/curve_points.png)

::: fragment
![Function $f(t)$](plots/arith_curve.png)
:::
:::

## Addition

::: columns
::: {.column width="65%"}
![$f(t) + \color{red}{g(t)}$](plots/arith_sum.png)
:::
:::

## Addition

::: columns
::: {.column width="65%"}
![$f(t) + \color{red}{g(t)} = \color{blue}{y(t)}$](plots/arith_sum_res.png)
:::
:::

## Multiplication by a scalar

::: columns
::: {.column width="65%"}
![$\color{red}{0.5} \cdot f(t)$](plots/arith_curve.png)
:::
:::

## Multiplication by a scalar

::: columns
::: {.column width="65%"}
![$\color{red}{0.5} \cdot f(t) = \color{blue}{y(t)}$](plots/arith_scalar.png)
:::
:::

## Multiplication by a scalar

::: columns
::: {.column width="65%"}
![$\color{red}{(-0.5)} \cdot f(t) = \color{blue}{y(t)}$](plots/arith_scalar_neg.png)
:::
:::

## Mean curve

::: columns
::: {.column width="65%"}
![$\frac{1}{2} \cdot (f(t) + \color{red}{g(t)})$](plots/arith_curve2.png)
:::
:::

## Mean function

::: columns
::: {.column width="65%"}
![$\frac{1}{2} \cdot (f(t) + \color{red}{g(t)}) = \color{blue}{y(t)}$](plots/arith_curve2mean.png)
:::
:::

# Functional PCA

## A curve dataset

![100 curves, two categories](plots/ex1D.1_curves.png){height="500"}


## Remove factors

![](plots/ex1D.1_curves_black.png){height="500"}

## Subtract mean curve

::: columns
::: {.column width="45%"}
![Mean $\mu(t)$](plots/ex1D.1_mean.png)
:::

::: {.column width="45%"}
![$f_i(t) - \mu(t)$](plots/ex1D.1_curves_demean.png)
:::

:::






## FPC curves

![](plots/ex1D.1_PC.png){height="500"}

## FPC scores

::: fragment
```{r}
#| echo: false
library(tidyverse)
PCscores <- read_csv("data/ex1D.1_PCscores.csv")
PCscores %>% 
  filter(curveId %in% c(1,2,3,51, 52, 53)) %>% 
  mutate(across(starts_with("s"), ~ round(.x, 2))) %>% 
  select(!(s4:last_col()))


```
:::




## FPC-based curve reconstruction

![$\color{blue}{\hat{f}(t)} = \mu(t)$](plots/ex1D.1_curve1_mean.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t) + \color{red}{(-0.21)} \cdot PC1(t)$](plots/ex1D.1_curve1_mean_PC1.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t) + \color{red}{(-0.21)} \cdot PC1(t) + \color{red}{0.21} \cdot PC2(t)$](plots/ex1D.1_curve1_mean_PC12.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t) + \color{red}{(-0.21)} \cdot PC1(t) + \color{red}{0.21} \cdot PC2(t) + \color{red}{(-0.02)} \cdot PC3(t)$](plots/ex1D.1_curve1_mean_PC123.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t)$](plots/ex1D.1_curve51_mean.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t) + \color{red}{0.21} \cdot PC1(t)$](plots/ex1D.1_curve51_mean_PC1.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t) + \color{red}{0.21} \cdot PC1(t) + \color{red}{0.04} \cdot PC2(t)$](plots/ex1D.1_curve51_mean_PC12.png){height="500"}

## FPC-based curve reconstruction {visibility="uncounted"}

![$\color{blue}{\hat{f}(t)} = \mu(t) + \color{red}{0.21} \cdot PC1(t) + \color{red}{0.04} \cdot PC2(t) + \color{red}{0.05} \cdot PC3(t)$](plots/ex1D.1_curve51_mean_PC123.png){height="500"}


## FPC scores controlling FPC curves

![](plots/ex1D.1_PCcolor.png){height="500"}


## Reintroduce factors

![](plots/ex1D.1_PCscores_scatter.png){height="500"}


## Fit a regression model on s~1~

```{r}
#| echo: true
#| output-location: fragment
mod <- lm(s1 ~ Category, data = PCscores)
summary(mod)
```

## Model predictions on s~1~

```{r}
#| echo: true
library(emmeans)
emmeans(mod, pairwise ~ Category)
```

## Reconstruct predicted curves from s~1~

$$ f_A(t) = \mu(t) + s_{1, A} \cdot PC1(t)$$ $$ f_B(t) = \mu(t) + s_{1, B} \cdot PC1(t)$$

## Reconstruct predicted curves from s~1~

![](plots/ex1D.1_pred_curves.png)


## GAM

```{r}
#| echo: true
#| eval: false
library(mgcv)
mod <- bam(y ~ Category + s(time, by = Category),
           data = curves)
```


::: fragment
![](plots/ex1D.1_GAM_smooth.png){height="500"}
:::



## References

::: {#refs}
:::
