---
title: "Orthogonal Projections and Functional PCA"
author: "Michele Gubian"
date: "25 September 2023"
date-format: long
format:
  revealjs:
    df-print: kable
editor: visual
fig-cap-location: top
tab-cap-location: top
---

# Motivation

## Statistics on a curve dataset

::: {layout-ncol="2"}
::: fragment
![](plots/curves.png)
:::

::: {.incremental}
* What is the shape of the typical curve for each Category?
* Are the Category levels significantly different?
* If so, where and how?
* Are there other systematic shape variations in the dataset?
:::

:::

## GAMMs

```{r}
#| echo: true
#| eval: false
library(mgcv)
mod <- bam(y ~ Category + s(time, by = Category),
           data = curves)
```

::: fragment
![](plots/plot_smooth.png)
:::

## GAMMs

```{r}
#| echo: true
#| eval: false
library(mgcv)
mod <- bam(y ~ Category + s(time, by = Category),
           data = curves)
```
![](plots/plot_diff.png)

## GAMMs 

::: {layout-ncol="2"}
::: fragment
### PROs

::: {.incremental}
* From raw sampled curves to model
* Native mixed model

:::

:::

::: fragment

### CONs
 
::: {.incremental}

* Not easy with multidimensional data
* No modelling of duration
* Can be computationally heavy

:::
:::

:::

## GAMMs

::: fragment
```{dot}

digraph G {
rankdir=LR;
  A[shape = plaintext label="sampled curves"]
  B[shape = box label="GAMM" style = rounded]
  C[shape = plaintext label = "model"]
  A -> B;
  B -> C;
  
}
```
:::

## Functional PCA

::: fragment
```{dot}
digraph G {
rankdir=LR;
  A[shape = plaintext label="sampled curves"]
  B[shape = box label="FPCA" style = rounded]
  C[shape = box label="LMER" style = rounded]
  D[shape = plaintext label = "model"]
  A -> B;
  B -> C;
  C -> D;
  
}
```
:::

## Functional PCA

::: {layout-ncol="2"}

::: fragment

### PROs
 
::: {.incremental}

* Native multidimensional data
* [Can model duration*]{style="color:red"}
* Computationally light
* Produces an intermediate model 

:::
:::




::: fragment
### CONs

::: {.incremental}
* Requires two steps
* Not native mixed model
* Intermediate model may not be effective

:::

:::


:::




# Functions

## Functions

> A function is a 'machine' that transforms numbers in a pre-specified way.

::: fragment
```{dot}

digraph G {
rankdir=LR;
  A[shape = plaintext label="x" fontname="times-italic"]
  B[shape = box label="f(x)" fontname="times-italic"  style = rounded]
  C[shape = plaintext label = "y" fontname="times-italic"]
  A -> B;
  B -> C;
  
}
```
:::




## Functions

Example:

```{dot}

digraph G {
rankdir=LR;
  A[shape = plaintext label=<<I>x</I>&nbsp; = 1.7>]
  B[shape = box label = <<I>x</I><SUP >2</SUP> + 3>  style = rounded]
  C[shape = plaintext label=<<I>y</I>&nbsp; = 1.7<SUP>2</SUP> + 3 = 5.89>]
  A -> B;
  B -> C;
}
```

## Functions

![](plots/f.png)

## From time samples to functions

::: {layout-ncol="2"}
![Samples](plots/samples.png)

::: fragment
![Function](plots/curve.png)
:::
:::

# Operations on functions

## Arithmetic

### Addition

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/add2.png)

::: fragment
![$f(t) + g(t)$](plots/curve_plus_add2.png)
:::
:::

## Arithmetic

### Addition

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/add3.png)

![$f(t) + g(t)$](plots/curve_plus_add3.png)
:::

## Arithmetic

### Multiplication by a scalar

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

::: fragment
![$0.5 \cdot f(t)$](plots/curve05.png)
:::

::: fragment
![$-0.5 \cdot f(t)$](plots/curvem05.png)
:::
:::

## Arithmetic

### Mean curve

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/curve2.png)

::: fragment
![$\mu(t) = \frac{1}{2} \cdot (f(t) + g(t))$](plots/curveMean2.png)
:::
:::

## Arithmetic

### Multiplication by a function

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/mul2.png)

::: fragment
![$f(t) \cdot g(t)$](plots/curve_times_mul2.png)
:::
:::

## Scalar product [^1]

[^1]: a.k.a. dot prodoct, a.k.a. inner product

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/mul2.png)

::: fragment
![$\langle f(t), g(t) \rangle$](plots/curvePoly2Int.png)
:::
:::

::: fragment
$\langle f(t), g(t) \rangle =$ [area above 0]{style="color:#006400;"} $-$ [area below 0]{style="color:#7CFC00;"} $= -0.15$
:::

## Scalar product

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/mul2.png)

![$\langle f(t), g(t) \rangle$](plots/curvePoly2Int.png)
:::

$\langle f(t), g(t) \rangle = \int_0^2 f(t) \cdot g(t) \; dt = -0.15$

# Orthogonal basis

## Orthogonal basis

> A set of functions such that the scalar product between any pair of them is zero

## Orthogonal basis

![Legendre polynomials](plots/Poly2by2.png){height="500"}


## Orthogonal basis


## Orthogonal projections

![](plots/orthogonalProjection.drawio.svg)

## Reconstruction

![](plots/reconstruction.drawio.svg)

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t)$](plots/curveRecPoly1.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t) + s_2 \cdot B2(t)$](plots/curveRecPoly2.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t) + s_2 \cdot B2(t) + s_3 \cdot B3(t)$](plots/curveRecPoly3.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t) + s_2 \cdot B2(t) + s_3 \cdot B3(t) + s_4 \cdot B4(t)$](plots/curveRecPoly4.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^8 s_k \cdot Bk(t)$](plots/curveRecPoly8.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^{12} s_k \cdot Bk(t)$](plots/curveRecPoly12.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^{16} s_k \cdot Bk(t)$](plots/curveRecPoly16.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^{20} s_k \cdot Bk(t)$](plots/curveRecPoly20.png){height="500"}

# Scores as shape descriptors

## Scores as shape descriptors


:::: {.columns}

::: {.column width="40%"}
![$f(t)$](plots/curve_shape.png)
:::

::: {.column width="20%"}
![Basis](plots/PolyAll4.png)
:::

::: {.column width="40%"}
| | |
|-------|------:|
| $s_1$ |  0.30 |
| $s_2$ | -0.15 |
| $s_3$ | -0.05 |
| $s_4$ |  0.05 |

:  Scores

:::
::::


## Scores as shape descriptors

:::: {.columns}

::: {.column width="40%"}
![$f(t) + 0.3$](plots/curve_plus03_shape.png)
:::

::: {.column width="20%"}
![Basis](plots/PolyAll4.png)
:::

::: {.column width="40%"}
| | |
|-------|------:|
| $s_1$ |  [0.72]{style="color:red"} |
| $s_2$ | -0.15 |
| $s_3$ | -0.05 |
| $s_4$ |  0.05 |

:  Scores

:::
::::


## Scores as shape descriptors

:::: {.columns}

::: {.column width="40%"}
![$f(2 - t)$](plots/curveRev_shape.png)
:::

::: {.column width="20%"}
![Basis](plots/PolyAll4.png)
:::

::: {.column width="40%"}
| | |
|-------|------:|
| $s_1$ |  0.30 |
| $s_2$ | [+0.15]{style="color:red;"} |
| $s_3$ | -0.05 |
| $s_4$ | [-0.05]{style="color:red;"} |

:  Scores

:::
::::

# Statistics with orthogonal projections

## A curve dataset

![](plots/curves.png)

## Subtract the mean curve

::: {layout-ncol="2"}
![$\mu(t)$](plots/meanCurve.png)

![$f_i(t) - \mu(t)$](plots/curvesCentred.png)
:::

## Compute scores

::: fragment
```{r}
#| echo: false
library(tidyverse)
polyScores <- read_csv("data/polyScores.csv")
polyScores %>% 
  filter(curveId %in% c(1,2,3,51, 52, 53)) %>% 
  mutate(across(starts_with("s"), ~ round(.x, 2)))

```
:::

## Fit a regression model on s1
```{r}
#| echo: true
#| output-location: fragment
mod <- lm(s1 ~ Category, data = polyScores)
summary(mod)
``` 

## Model predictions on s1

```{r}
#| echo: true
library(emmeans)
emmeans(mod, pairwise ~ Category)
``` 

## Reconstruct predicted curves from s1

$$ f_{PEAK}(t) = \mu(t) + s_{1, PEAK} \cdot B1(t)$$
$$ f_{NO\_PEAK}(t) = \mu(t) + s_{1, NO\_PEAK} \cdot B1(t)$$

## Reconstruct predicted curves from s1

![](plots/emmCurves_Poly_s1.png)

## Reconstruct predicted curves from s1, s2, s3, s4

$$ f_{PEAK}(t) = \mu(t) + \sum_{k \in \{1, 2, 3, 4\}} s_{k, PEAK} \cdot Bk(t)$$
$$ f_{NO\_PEAK}(t) = \mu(t) + \sum_{k \in \{1, 2, 3, 4\}} s_{k, NO\_PEAK} \cdot Bk(t)$$

## Reconstruct predicted curves from s1, s2, s3, s4

![](plots/emmCurves_Poly_s1234.png)

# Functional PCA

## Functional PCA

::: {.incremental}
1. [Construct]{style="color:red"} an orthogonal basis [optimised on your curve dataset]{style="color:red"} 
2. Compute orthogonal projections (scores)
:::

## Principal Components (PCs)

![](plots/PC.png)

<!-- ## Explained variance -->

<!-- | PC1  | PC2  | PC3  | PC4 | -->
<!-- |------:|------:|------:|------:| -->
<!-- | 99.59% | 0.24% |  0.11% |  0.05% | -->

## Compute scores

```{r}
#| echo: false

pcScores <- read_csv("data/pcScores.csv")
pcScores %>% 
  filter(curveId %in% c(1,2,3,51, 52, 53)) %>% 
  mutate(across(starts_with("s"), ~ round(.x, 4)))

```

## PCs and scores

![](plots/ex1D.1.FPCA_curves.png)

## Fit a regression model on s1
```{r}
#| echo: true
mod <- lm(s1 ~ Category, data = pcScores)
emmeans(mod, pairwise ~ Category)
``` 


## Reconstruct predicted curves from s1

$$ f_{PEAK}(t) = \mu(t) + s_{1, PEAK} \cdot PC1(t)$$
$$ f_{NO\_PEAK}(t) = \mu(t) + s_{1, NO\_PEAK} \cdot PC1(t)$$

## Reconstruct predicted curves from s1

![](plots/emmCurves_PCs1.png)

# Multi-dimensional FPCA

## A two-dimensional curve dataset

![](plots/ex2D.1.curves.png)

## D-dimensional Principal Components

::: {.incremental}

* There are D mean curves
  - $\mu_{y1}(t)$ and $\mu_{y2}(t)$
* Each PC is composed of D curves
  - $PC1_{y1}(t)$ and $PC1_{y2}(t)$, $PC2_{y1}(t)$ and $PC2_{y2}(t)$, etc.
* [Scores do not increase]{style="color:red"} 
* Each score controls a PC, which is made of D 1-dimensional curves
  - $s_1$ controls (i.e. multiplies) $PC1_{y1}(t)$ and $PC1_{y2}(t)$

:::



## Principal Components (PCs)

![](plots/ex2D.1.FPCA_curves.png)


## Compute scores

![](plots/ex2D.1.PCscores_scatter.png)


## Fit a regression model on s1
```{r}
#| echo: true
#| eval: false
mod <- lm(s1 ~ Category, data = pcScores)
emmeans(mod, pairwise ~ Category)
``` 
| Category | $s_1$ |
|-------|------:|
| HIGH_PEAK  | -0.12 |
| LOW_PEAK   | 0.12  |

## Reconstruct predicted curves from s1

::: fragment
$$ y1_{HIGH\_PEAK}(t) = \mu_{y1}(t) + \color{red}{s_{1, HIGH\_PEAK}} \cdot PC1_{y1}(t)$$
$$ y2_{HIGH\_PEAK}(t) = \mu_{y2}(t) + \color{red}{s_{1, HIGH\_PEAK}} \cdot PC1_{y2}(t)$$
:::

::: fragment
$$ y1_{LOW\_PEAK}(t) = \mu_{y1}(t) + \color{red}{s_{1, LOW\_PEAK}} \cdot PC1_{y1}(t)$$
$$ y2_{LOW\_PEAK}(t) = \mu_{y2}(t) + \color{red}{s_{1, LOW\_PEAK}} \cdot PC1_{y2}(t)$$
:::

## Reconstruct predicted curves from s1

![](plots/ex2D.1.pred_curves.png)
