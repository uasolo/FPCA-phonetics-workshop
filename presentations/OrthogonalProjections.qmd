---
title: "Orthogonal projections"
author: "Michele Gubian"
date: "25 September 2023"
format:
  revealjs:
    df-print: kable
editor: visual
fig-cap-location: top
tab-cap-location: top
---

# Functions

## Functions

A function is a 'machine' that transforms numbers in a pre-specified way.

::: fragment
```{dot}

digraph G {
rankdir=LR;
  A[shape = plaintext label="x", fontname="times-italic"]
  B[shape = box label="f(x)", fontname="times-italic"]
  C[shape = plaintext label = "y", fontname="times-italic"]
  A -> B;
  B -> C;
  
}
```
:::

## Functions

Example:

```{dot}

digraph G {
rankdir=LR;
  A[shape = plaintext label=<<I>x</I>&nbsp; = 1.7>]
  B[shape = box label = <<I>x</I><SUP >2</SUP> + 3>]
  C[shape = plaintext label=<<I>y</I>&nbsp; = 1.7<SUP>2</SUP> + 3 = 5.89>]
  A -> B;
  B -> C;
}
```

## Functions

![](plots/f.png)

## From time samples to functions

::: {layout-ncol="2"}
![Samples](plots/samples.png)

::: fragment
![Function](plots/curve.png)
:::
:::

# Operations on functions

## Arithmetic

### Addition

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/add2.png)

::: fragment
![$f(t) + g(t)$](plots/curve_plus_add2.png)
:::
:::

## Arithmetic

### Addition

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/add3.png)

![$f(t) + g(t)$](plots/curve_plus_add3.png)
:::

## Arithmetic

### Multiplication by a scalar

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

::: fragment
![$0.5 \cdot f(t)$](plots/curve05.png)
:::

::: fragment
![$-0.5 \cdot f(t)$](plots/curvem05.png)
:::
:::

## Arithmetic

### Mean curve

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/curve2.png)

::: fragment
![$\mu(t) = \frac{1}{2} \cdot (f(t) + g(t))$](plots/curveMean2.png)
:::
:::

## Arithmetic

### Multiplication by a function

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/mul2.png)

::: fragment
![$f(t) \cdot g(t)$](plots/curve_times_mul2.png)
:::
:::

## Scalar product [^1]

[^1]: a.k.a. dot prodoct, a.k.a. inner product

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/mul2.png)

::: fragment
![$\langle f(t), g(t) \rangle$](plots/curvePoly2Int.png)
:::
:::

::: fragment
$\langle f(t), g(t) \rangle =$ [area above 0]{style="color:#006400;"} $-$ [area below 0]{style="color:#7CFC00;"} $= -0.15$
:::

## Scalar product

::: {layout-ncol="3"}
![$f(t)$](plots/curve.png)

![$g(t)$](plots/mul2.png)

![$\langle f(t), g(t) \rangle$](plots/curvePoly2Int.png)
:::

$\langle f(t), g(t) \rangle = \int_0^2 f(t) \cdot g(t) \; dt = -0.15$

# Orthogonal basis

## Orthogonal basis

> A set of functions such that the scalar product between any pair of them is zero

## Orthogonal basis

### (Legendre polynomials)

::: {layout-ncol="2"}
![$B1(t)$](plots/Poly1.png)

![$B2(t)$](plots/Poly2.png)
:::

## Orthogonal basis

### (Legendre polynomials)

::: {layout-ncol="2"}
![$B3(t)$](plots/Poly3.png)

![$B4(t)$](plots/Poly4.png)
:::

## Orthogonal projections

![](plots/orthogonalProjection.drawio.svg)

## Reconstruction

![](plots/reconstruction.drawio.svg)

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t)$](plots/curveRecPoly1.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t) + s_2 \cdot B2(t)$](plots/curveRecPoly2.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t) + s_2 \cdot B2(t) + s_3 \cdot B3(t)$](plots/curveRecPoly3.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = s_1 \cdot B1(t) + s_2 \cdot B2(t) + s_3 \cdot B3(t) + s_4 \cdot B4(t)$](plots/curveRecPoly4.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^8 s_k \cdot Bk(t)$](plots/curveRecPoly8.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^{12} s_k \cdot Bk(t)$](plots/curveRecPoly12.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^{16} s_k \cdot Bk(t)$](plots/curveRecPoly16.png){height="500"}

## Reconstruction accuracy

![$\color{blue}{\hat{f}(t)} = \sum_{k=1}^{20} s_k \cdot Bk(t)$](plots/curveRecPoly20.png){height="500"}

# Scores as shape descriptors

## Scores as shape descriptors


:::: {.columns}

::: {.column width="40%"}
![$f(t)$](plots/curve_shape.png)
:::

::: {.column width="20%"}
![Basis](plots/PolyAll4.png)
:::

::: {.column width="40%"}
| | |
|-------|------:|
| $s_1$ |  0.30 |
| $s_2$ | -0.15 |
| $s_3$ | -0.05 |
| $s_4$ |  0.05 |

:  Scores

:::
::::


## Scores as shape descriptors

:::: {.columns}

::: {.column width="40%"}
![$f(t) + 0.3$](plots/curve_plus03_shape.png)
:::

::: {.column width="20%"}
![Basis](plots/PolyAll4.png)
:::

::: {.column width="40%"}
| | |
|-------|------:|
| $s_1$ |  [0.72]{style="color:red;"} |
| $s_2$ | -0.15 |
| $s_3$ | -0.05 |
| $s_4$ |  0.05 |

:  Scores

:::
::::


## Scores as shape descriptors

:::: {.columns}

::: {.column width="40%"}
![$f(2 - t)$](plots/curveRev_shape.png)
:::

::: {.column width="20%"}
![Basis](plots/PolyAll4.png)
:::

::: {.column width="40%"}
| | |
|-------|------:|
| $s_1$ |  0.30 |
| $s_2$ | [+0.15]{style="color:red;"} |
| $s_3$ | -0.05 |
| $s_4$ | [-0.05]{style="color:red;"} |

:  Scores

:::
::::

# Statistics with orthogonal projections

## A curve dataset

![](plots/curves.png)

## Subtract the mean curve

::: {layout-ncol="2"}
![$\mu(t)$](plots/meanCurve.png)

![$f_i(t) - \mu(t)$](plots/curvesCentred.png)
:::

## Compute scores

::: fragment
```{r}
#| echo: false

library(tidyverse)
polyScores <- read_csv("data/polyScores.csv")
polyScores %>% 
  filter(curveId %in% c(1,2,3,51, 52, 53)) %>% 
  mutate(across(starts_with("s"), ~ round(.x, 2)))

```
:::

## Fit a regression model on a s4
```{r}
#| echo: true
mod <- lm(s4 ~ Category, data = polyScores)
summary(mod)
``` 

## Model predictions on s4

```{r}
#| echo: true
library(emmeans)
emm <- emmeans(mod, pairwise ~ Category)
emm
``` 

## Reconstruct predicted curves from s4

$$ f_{PEAK}(t) = \mu(t) + s_{4, PEAK} \cdot B4(t)$$
$$ f_{NO\_PEAK}(t) = \mu(t) + s_{4, NO\_PEAK} \cdot B4(t)$$

