---
title: "GAMMs and time alignment"
author: "Michele Gubian"
date: "May 2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(tidyverse)
library(ggthemes)
library(magrittr)
library(mgcv)
library(itsadug)
library(emmeans)
library(RColorBrewer)
```

Here we present two datasets where curves do not have the same duration.

## Dataset 1

```{r }

# home_dir <- "/vdata/ERC2/FPCA/FPCA-phonetics-workshop"
data_dir <- '../data'
ex <- 1 
lin_t1 <- 0.65 # linear time distortion
curves <- read_csv(file.path(data_dir, paste("ex1D", ex, "csv", sep = '.'))) %>% 
  mutate(Category = factor(Category)) %>% 
  group_by(curveId) %>% 
  mutate(t1 = runif(1, lin_t1, 1/lin_t1) * time)
           
nCurves <- curves %>% select(curveId) %>% n_distinct()

Category.colors <- c("slategray4", "orangered")
Category.labels <- c(NO_PEAK = "NP (No Peak)", PEAK = "P (Peak)")
# plot a few curves
ggplot(curves %>%
         filter(curveId %in% sample(nCurves, 20)) %>%
         mutate(curveId = factor(curveId))) +
  aes(x = t1, y = y, group = curveId, color = curveId) +
  geom_line(linewidth = 0.3) +
  facet_grid(~ Category, labeller = labeller(Category = Category.labels)) +
  xlab("time") +
  theme_light() +
  theme(text = element_text(size = 15),
        legend.position = "none")

```

Let us investigate two common approaches to time normalisation prior to GAMM modelling. 

### Approach 1: No time normalisation

```{r fig.show="hold"}
m1 <- bam(y ~ Category + s(t1, by = Category), data = curves)
summary(m1)
plot_smooth(m1, view = "t1",  plot_all = "Category", 
            col = Category.colors,  print.summary = FALSE, rug = FALSE)
```

Notice that:

* The model does not complain if the curves have different durations
  - actually, it does not know there are curves!
* Confidence bands get wider towards the end
* Predicted curves are not capturing the salient second peak quite well (var explained 77%)

### Approach 2: Linear time normalisation

```{r fig.show="hold"}
ggplot(curves %>%
         group_by(curveId) %>% 
         mutate(t_lin = t1/max(t1)) %>% 
         ungroup() %>% 
         filter(curveId %in% sample(nCurves, 20)) %>%
         mutate(curveId = factor(curveId))) +
  aes(x = t_lin, y = y, group = curveId, color = curveId) +
  geom_line(linewidth = 0.3) +
  facet_grid(~ Category, labeller = labeller(Category = Category.labels)) +
  theme_light() +
  xlab("lin. norm. time") +
  theme(text = element_text(size = 15),
        legend.position = "none")
m2 <- bam(y ~ Category + s(t_lin, by = Category),
          data = curves %>%
            group_by(curveId) %>% 
            mutate(t_lin = t1/max(t1)))
summary(m2)
plot_smooth(m2, view = "t_lin",  plot_all = "Category", 
            col = Category.colors,  print.summary = FALSE, rug = FALSE)
```

In this case the result is excellent (var explained 97%). In fact, the data were generated by randomly applying a random linear time distorsion to each curve.

## Dataset 2

Suppose the data look like this instead:


```{r }
max_chop <- 0.6 
set.seed(28)
# plot a few curves
ggplot(curves %>%
         group_by(curveId) %>% 
         filter(time < runif(1, max_chop * max(time), max(time))) %>% 
         ungroup() %>% 
         filter(curveId %in% sample(nCurves, 10)) %>%
         mutate(curveId = factor(curveId))) +
  aes(x = time, y = y, group = curveId, color = curveId) +
  geom_line(linewidth = 0.3) +
  facet_grid(~ Category, labeller = labeller(Category = Category.labels)) +
  theme_light() +
  xlab("time") +
  theme(text = element_text(size = 15),
        legend.position = "none")

```

Let us apply the same approaches as in dataset 1.

### Approach 1: No time normalisation

```{r fig.show="hold"}
set.seed(28)
chop_curves <- curves %>% 
             group_by(curveId) %>% 
             filter(time < runif(1, max_chop * max(time), max(time))) %>% 
            ungroup()
m3 <- bam(y ~ Category + s(time, by = Category),
          data = chop_curves)
summary(m3)
plot_smooth(m3, view = "time",  plot_all = "Category", 
            col = Category.colors,  print.summary = FALSE, rug = FALSE)
```

This is the perfect solution in this case. In fact, the data were generated by chopping the curves randmoly towards the end.

### Approach 2: Linear time normalisation

```{r fig.show="hold"}
# plot a few curves
ggplot(chop_curves %>%
            group_by(curveId) %>% 
            mutate(t_lin = time/max(time)) %>%
         ungroup() %>% 
         filter(curveId %in% sample(nCurves, 10)) %>%
         mutate(curveId = factor(curveId))) +
  aes(x = t_lin, y = y, group = curveId, color = curveId) +
  geom_line(linewidth = 0.3) +
  facet_grid(~ Category, labeller = labeller(Category = Category.labels)) +
  xlab("linear norm. time") +
  theme_light() +
  theme(text = element_text(size = 15),
        legend.position = "none")
m4 <- bam(y ~ Category + s(t_lin, by = Category),
          data = chop_curves %>%
            group_by(curveId) %>% 
            mutate(t_lin = time/max(time)))
summary(m4)
plot_smooth(m4, view = "t_lin",  plot_all = "Category", 
            col = Category.colors,  print.summary = FALSE, rug = FALSE)
```

This time linear time normalisation creates distortions and artifacts in the solution.

## Interim conclusions

* GAMMs are agnostic and transparent to what we do to the time axis
* Time alignment has to be solved independently and prior to GAMM estimation
* There is no one-size-fits-all solution

# Correlation between shape and duration

```{r}
lin_expansion <- 1.5
set.seed(28)
curves %>% 
  filter(Category  == "PEAK") %>% 
  group_by(curveId) %>% 
  mutate(across(c(y, t1), ~ runif(1, 1/lin_expansion, lin_expansion) * .x)) %>%
  inner_join(curves %>%
               filter(Category  == "PEAK") %>%
               distinct(curveId) %>% 
               slice_sample(n = 20)) %>% 
  mutate(curveId = factor(curveId)) %>% 
  ggplot() +
  aes(t1, y, group = curveId, color = curveId) +
  geom_line(linewidtth=0.3) +
  xlab("time") +
  theme_light() +
  theme(text = element_text(size = 15),
        legend.position = "none")


```





